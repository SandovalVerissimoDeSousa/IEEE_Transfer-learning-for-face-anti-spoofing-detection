import os
import cv2
import numpy as np

from tqdm import tqdm


def __remove_invalid_chars(row, col):
    content = row[col]
    content = content.replace('[','')
    content = content.replace(']','')
    content = content.replace(' ', '')
    return content


def __clean_face_bbox(face_infos_df):
    face_infos_df['Face'] = face_infos_df.apply(lambda row: __remove_invalid_chars(row, 'Face'), axis=1)
    face_infos_df['Left_Eye'] = face_infos_df.apply(lambda row: __remove_invalid_chars(row, 'Left_Eye'), axis=1)
    face_infos_df['Right_Eye'] = face_infos_df.apply(lambda row: __remove_invalid_chars(row, 'Right_Eye'), axis=1)
    return face_infos_df


'''
 Align, crop and resize images given a pandas dataframe with the faces bounding boxes and saves the processed output image.

 Parameters:
  . face_infos_df: Dataframe generated by BioPass with Nome,Face,Left_Eye,Right_Eye columns.
  . output_dir_path: Root directory where the images will be saved. Will be created if already doesn't exists.  
  . input_dir_root_path: Root directory where the images listed into dataframe are located.
  . dist_between_eyes: Distance between eyes and border in 0 to 1, smaller number equals more distance between eyes.
  . width_height: Output shape in width and height.

 Output: None
'''
def align_faces(face_infos_df, output_dir_root_path, input_dir_root_path, dist_between_eyes = (0.275,0.275), width_height = (224,224)):
    face_infos_df = __clean_face_bbox(face_infos_df)

    #setup parameters
    dist_eyes = dist_between_eyes
    desired_face_width = width_height[0]
    desired_face_height = width_height[1]

    count = 0
    #for each entry in the dataframe.
    for _,row in tqdm(face_infos_df.iterrows()):
        input_file_path = os.path.join(input_dir_root_path, row.origin, row.split, row.label, row.img_name)
        
        if not os.path.exists(input_file_path):
            print(count, " ERROR: ", input_file_path, "Not Exists!")

        output_img = __align_face_img(dist_eyes, desired_face_width, desired_face_height, row, input_file_path)
        
        __record_aligned_face_img(output_dir_root_path, row, output_img)


def __align_face_img(dist_eyes, desired_face_width, desired_face_height, row, input_file_path):
    #asserts values received from landmark detection.
    left_x,left_y = [int(val) for val in row.Left_Eye.split(",")]
    right_x, right_y = [int(val) for val in row.Right_Eye.split(",")]

    #calculates center between eyes point.
    center_x = int((left_x+right_x)/2)
    center_y = int((left_y+right_y)/2)

    #calculates rotation angle between eyes.
    dX = right_x-left_x
    dY = right_y-left_y
    angle = np.degrees(np.arctan2(dY, dX)) - 180
    #print(angle)

    #Calculates porportion of distance between eyes on the whole image.
    desired_comp_dist = 1.0 - dist_eyes[0]
    dist = np.sqrt((dX ** 2) + (dY ** 2))
    desired_dist = (desired_comp_dist - dist_eyes[0])
    #print(desired_dist)
    desired_dist *= desired_face_width
    #print(desired_dist)
    scale = desired_dist / dist
    #print(h,w, scale)

    #Get rotation matrix of the image following the scale,and angle calculated previously.
    eyesCenter = (center_x, center_y)
    M = cv2.getRotationMatrix2D(eyesCenter, angle, scale)
    tX = desired_face_width * 0.5
    tY = desired_face_height * dist_eyes[1]
    M[0, 2] += (tX - eyesCenter[0])
    M[1, 2] += (tY - eyesCenter[1])

    input_img = cv2.imread(input_file_path)

    #Applies the rotation matrix
    output_img = cv2.warpAffine(input_img, M, (desired_face_width, desired_face_height), flags=cv2.INTER_CUBIC)
    return output_img


def __record_aligned_face_img(output_dir_root_path, row, output_img):
    output_dir_path = os.path.join(output_dir_root_path, row.origin, row.split, row.label)
    dest_file_path = os.path.join(output_dir_path, row.img_name)

    os.makedirs(output_dir_path, exist_ok=True)
    cv2.imwrite(dest_file_path, output_img)
        
